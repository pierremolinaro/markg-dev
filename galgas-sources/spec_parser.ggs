#---------------------------------------------------------------------------*
#                                                                           *
#   S Y N T A X                                                             *
#                                                                           *
#---------------------------------------------------------------------------*

syntax spec_parser (spec_scanner) {

rule <axiome>(
  !@uint outHashMapSize
  !@uint outGarbagePeriod
  !@typeVarMap outPlacesMap
  !@typeTransitionList outTransitionList
  !@typeInitialMarkingList outInitialMarkingList
  !@countList outCountList)

rule <parse_precondition>(
  ?!@typeVarMap outPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePreconditionExpression outPreConditions)

rule <term>(
  ?!@typeVarMap outPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePreconditionExpression outPreConditions)

rule <factor>(
  ?!@typeVarMap outPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePreconditionExpression outPreConditions)

rule <primary>(
  ?!@typeVarMap outPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePreconditionExpression outPreConditions)

rule <parse_postcondition>(
  ?!@typeVarMap outPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePostconditionList outPostConditionsList)

rule <parse_constant>(
  ?!@typeCstMap ioConstantMap
  !@bool outSign
  !@luint outValue)

rule <parse_bound>(
 !@uint lowTemporalBound
 !@uint highTemporalBound)

#---------------------------------------------------------------------------*

rule <parse_precondition>(
  ?!@typeVarMap inPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePreconditionExpression outPreConditions) {
  <term>( !?inPlacesMap !?ioConstantMap ?outPreConditions)
  repeat
  while
    $|$
    <term>( !?inPlacesMap !?ioConstantMap ?let right)
    outPreConditions = @typeOrExpression. new ( !outPreConditions !right)
  end
}

#---------------------------------------------------------------------------*

rule <term>(
  ?!@typeVarMap inPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePreconditionExpression outPreConditions) {
  <factor>( !?inPlacesMap !?ioConstantMap ?outPreConditions)
  repeat
  while
    $&$
    <factor>( !?inPlacesMap !?ioConstantMap ?let right)
    outPreConditions = @typeAndExpression. new ( !outPreConditions !right)
  end
}

#---------------------------------------------------------------------------*

rule <factor>(
  ?!@typeVarMap inPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePreconditionExpression outPreConditions) {
 select
   $~$
   <factor>( !?inPlacesMap !?ioConstantMap ?outPreConditions)
   outPreConditions = @typeComplementExpression. new ( !outPreConditions)
  or
   <primary>( !?inPlacesMap !?ioConstantMap ?outPreConditions)
  end
}

#---------------------------------------------------------------------------*

rule <primary>(
  ?!@typeVarMap inPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePreconditionExpression outPreConditions) {
  select
    $($
    <parse_precondition>( !?inPlacesMap !?ioConstantMap ?outPreConditions)
    $)$
  or
    $true$
    outPreConditions = @typeTrueExpression. new
  or
    $false$
    outPreConditions = @typeFalseExpression. new
  or
    ${$
    $identifier$( ?let name)
    [inPlacesMap searchKey !name ?let idx]
    select
      $==$
      <parse_constant>( !?ioConstantMap ?let sign ?let cst)
      outPreConditions = @typeEqualExpression. new ( !idx !sign !cst)
    or
      $!=$
      <parse_constant>( !?ioConstantMap ?let sign ?let cst)
      outPreConditions = @typeNonEqualExpression. new ( !idx !sign !cst)
    or
      $<=$
      <parse_constant>( !?ioConstantMap ?let sign ?let cst)
      outPreConditions = @typeInfOrEqualExpression. new ( !idx !sign !cst)
    or
      $>=$
      <parse_constant>( !?ioConstantMap ?let sign ?let cst)
      outPreConditions = @typeSupOrEqualExpression. new ( !idx !sign !cst)
    or
      $<$
      <parse_constant>( !?ioConstantMap ?let sign ?let cst)
      outPreConditions = @typeStrictInfExpression. new ( !idx !sign !cst)
    or
      $>$
      <parse_constant>( !?ioConstantMap ?let sign ?let cst)
      outPreConditions = @typeStrictSupExpression. new ( !idx !sign !cst)
    end
    $}$
  end
}

#---------------------------------------------------------------------------*

rule <parse_constant>(
  ?!@typeCstMap ioConstantMap
  !@bool outSign
  !@luint outValue) {
  select
    $identifier$( ?let constantName)
    [ioConstantMap searchKey !constantName ?outSign ?outValue]
  or
    $-$
    outSign = true
    $literal_integer$( ? outValue)
  or
    outSign = false
    $literal_integer$( ? outValue)
  end
}

#---------------------------------------------------------------------------*

rule <parse_postcondition>(
  ?!@typeVarMap outPlacesMap
  ?!@typeCstMap ioConstantMap
  !@typePostconditionList outPostConditionsList) {
  outPostConditionsList = @typePostconditionList. emptyList
  repeat
    $identifier$( ?let name)
    [outPlacesMap searchKey !name ?let idx]
    let @typePostcondition p
    select
      $--$
      p = @typePostDecrement. new ( !name !idx)
    or
      $++$
      p = @typePostIncrement. new ( !name !idx)
    or
      $+=$
      <parse_constant>( !?ioConstantMap ?let sign ?let cst)
      p = @typeAddConstant. new ( !name !idx !sign !cst)
    or
      $-=$
      <parse_constant>( !?ioConstantMap ?let sign ?let cst)
      p = @typeSubConstant. new ( !name !idx !sign !cst)
    or
      $:=$
      select
        <parse_constant>( !?ioConstantMap ?let sign ?let cst)
        p = @typeAssignConstant. new ( !name !idx !sign !cst)
      or
        $infinity$
        p = @typeAssignInfinity. new ( !name !idx)
      end
    end
    outPostConditionsList += !p
  while
    $,$
  end
}

#---------------------------------------------------------------------------*

rule <parse_bound>(
 !@uint lowTemporalBound
 !@uint highTemporalBound) {
  lowTemporalBound = 0
  highTemporalBound = 0
}

#---------------------------------------------------------------------------*

rule <parse_bound>(
 !@uint lowTemporalBound
 !@uint highTemporalBound) {
  $[$
  $literal_integer$( ?let low)
  $,$
  $literal_integer$( ?let high)
  $]$
  lowTemporalBound = low.uint
  highTemporalBound = high.uint
  if lowTemporalBound > highTemporalBound then
    error high : "High bound must be greater than or equal to low bound" 
  end
}

##---------------------------------------------------------------------------*
#
#abstract class @MyAbstractClass {
# @typeInitialMarkingList mInitialMarkingList ;
#}
#
##---------------------------------------------------------------------------*
#
#class @MyClass extends @MyAbstractClass {
# @typeTransitionList mTransitionList ;
#}
#
##---------------------------------------------------------------------------*

rule <axiome>(
  !@uint outHashMapSize
  !@uint outGarbagePeriod
  !@typeVarMap outPlacesMap
  !@typeTransitionList outTransitionList
  !@typeInitialMarkingList outInitialMarkingList
  !@countList outCountList) {
  $system$
#--- Options
  select
    $hashmapsize$
    $literal_integer$( ?let n)
    $;$
    outHashMapSize = n.uint
  or
    outHashMapSize = 16
  end
  select
    $garbageperiod$
    $literal_integer$( ?let n)
    $;$
    outGarbagePeriod = n.uint
  or
    outGarbagePeriod = 16
  end
  outTransitionList = @typeTransitionList. emptyList
  outPlacesMap = @typeVarMap. emptyMap
  var constantMap =@typeCstMap.emptyMap()
  outCountList = @countList. emptyList
  repeat
#--- constant
  while
    $const$
    $identifier$( ?let constantName)
    $=$
    <parse_constant>( !?constantMap ?let sign ?let value)
    [!?constantMap insertKey !constantName !sign !value]
    $;$
#--- Variables
  while
    $var$
    repeat
      $identifier$( ?let placeName)
      [!?outPlacesMap insertKey !placeName ![outPlacesMap count]]
    while
      $,$
    end
    $;$
#--- Rule
  while
    $rule$
    $literal_string$( ?let transitionName)
    <parse_precondition>( !?outPlacesMap !?constantMap ?let preConditions)
    <parse_bound>( ?let lowTemporalBound ?let highTemporalBound)
    $:$
    <parse_postcondition>( !?outPlacesMap !?constantMap ?let postConditions)
    $;$
    outTransitionList += !transitionName !preConditions !postConditions !lowTemporalBound !highTemporalBound
  end
#--- Init
  $init$
  outInitialMarkingList = @typeInitialMarkingList. emptyList
  repeat
    $identifier$( ?let placeName)
    [outPlacesMap searchKey !placeName ?let placeID]
    $:=$
    select
      <parse_constant>( !?constantMap ?let sign ?let cst)
      let @typePostcondition init = @typeAssignConstant. new ( !placeName !placeID !sign !cst)
      outInitialMarkingList += !init
    or
      $infinity$
      let @typePostcondition init = @typeAssignInfinity. new ( !placeName !placeID)
      outInitialMarkingList += !init
    end
  while
    $,$
  end
  $;$
#--- Count list
  repeat
  while
    $count$
    $literal_string$( ?let name)
    $:$
    <parse_precondition>( !?outPlacesMap !?constantMap ?let conditions)
    $;$
    outCountList += !name !conditions
  end
  $end$
}

}